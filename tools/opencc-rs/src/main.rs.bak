use std::fs::File;
use std::io::{self, BufWriter, Read, Write};

use clap::error::ContextValue::String;
use clap::{App, Arg};

use opencc_fmmseg;
use opencc_fmmseg::OpenCC;

fn main() -> io::Result<()> {
    let matches = App::new("OpenCC Rust")
        .arg(
            Arg::with_name("input")
                .short('i')
                .long("input")
                .value_name("file")
                .help("Read original text from <file>.")
                .takes_value(true)
                .required(true),
        )
        .arg(
            Arg::with_name("output")
                .short('o')
                .long("output")
                .value_name("file")
                .help("Write converted text to <file>.")
                .takes_value(true)
                .required(true),
        )
        .arg(
            Arg::with_name("config")
                .short('c')
                .long("config")
                .value_name("conversion")
                .help("Conversion configuration: [s2t|s2tw|s2twp|t2s|tw2s|tw2sp|..]")
                .takes_value(true)
                .required(true),
        )
        .arg(
            Arg::with_name("punct")
                .short('p')
                .long("punct")
                .value_name("boolean")
                .help("Punctuation conversion: [true|false]")
                .takes_value(true),
        )
        .get_matches();

    let input_file = matches.value_of("input");
    let output_file = matches.value_of("output");
    let config = matches.value_of("config").unwrap();
    let punctuation = matches
        .value_of("punct")
        .map_or(false, |value| value == "true");

    let mut input: Box<dyn Read> = match input_file {
        Some(file_name) => Box::new(File::open(file_name)?),
        None => Box::new(io::stdin()),
    };

    let output: Box<dyn Write> = match output_file {
        Some(file_name) => Box::new(File::create(file_name)?),
        None => Box::new(io::stdout()),
    };

    let mut output_buf = BufWriter::new(output);

    let mut input_str = String::new();
    input.read_to_string(&mut input_str)?;

    let output_str = convert_by(&input_str, &config, punctuation);

    write!(output_buf, "{}", output_str)?;

    output_buf.flush()?; // Flush buffer to ensure all data is written

    Ok(())
}

fn convert_by(input: &str, config: &str, punctuation: bool) -> String {
    let opencc = OpenCC::new();
    let result;

    match config.to_lowercase().as_str() {
        "s2t" => result = opencc.s2t(input, punctuation),
        "s2tw" => result = opencc.s2tw(input, punctuation),
        "s2twp" => result = opencc.s2twp(input, punctuation),
        "s2hk" => result = opencc.s2hk(input, punctuation),
        "t2s" => result = opencc.t2s(input, punctuation),
        "t2tw" => result = opencc.t2tw(input),
        "t2twp" => result = opencc.t2twp(input),
        "t2hk" => result = opencc.t2hk(input),
        "tw2s" => result = opencc.tw2s(input, punctuation),
        "tw2sp" => result = opencc.tw2sp(input, punctuation),
        "tw2t" => result = opencc.tw2t(input),
        "tw2tp" => result = opencc.tw2tp(input),
        "hk2s" => result = opencc.hk2s(input, punctuation),
        "hk2t" => result = opencc.hk2t(input),
        "jp2t" => result = opencc.jp2t(input),
        "t2jp" => result = opencc.t2jp(input),
        _ => {
            result = {
                OpenCC::set_last_error(format!("Invalid config: {}", config).as_str());
                String::new()
            }
        }
    }
    result
}
